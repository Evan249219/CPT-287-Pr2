import java.util.*;
import java.util.Stack;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.Scanner;

public class main {

	public static void main(String[] args) throws IOException {
		//Open input file, scanner, output file, and writer
		FileInputStream inputFile = new FileInputStream("E:/downloads/input.txt");
		Scanner scanner = new Scanner(inputFile);
		
		//Scan input file and call the functions to calculate expressions from input file
		while (scanner.hasNextLine()) {
			String infixExp = scanner.nextLine();
			//insert function for converting infix to postfix
			String postfix = infixToPostfix(infixExp);
			//insert function to evaluate postfix expression and print to screen
			//System.out.println("Postfix is: " + postfix);
			System.out.println(evaluatePostfix(postfix));
		}
		scanner.close();
		inputFile.close();
		
		
	}


	
	
	
	


	public static int evaluatePostfix (String str) {
		
		//create a stack
		Stack<Integer> stack = new Stack<>();
		
		//scan all characters in str
		for(int i = 0; i < str.length(); i++) {
			char scan = str.charAt(i);
			
			if(scan == ' ') {
				continue;
			}
			
			//if scan is a number, push to stack
			else if(Character.isDigit(scan)) {
				int n = 0;
				
				//extract and store characters, this is for numbers with multiple digits (10, 11, etc)
				while(Character.isDigit(scan)) {
					n = n*10 + (int)(scan - '0');
					i++;
					scan = str.charAt(i);
				}
				i--;
				stack.push(n);
			}
			
			//else the character is an operator, pop 2 elements and apply operator
			else {
				//System.out.println(Arrays.toString(stack.toArray()));
				//System.out.println("Stack capacity is: " + stack.size());
				int val1 = stack.pop();
				int val2 = stack.pop();
				StringBuilder compstr = new StringBuilder();
				
				
				//using a switch case until that is coded
				switch(scan) {
				case '+':
					stack.push(val2 + val1);
					break;
				
				case '-':
					stack.push(val2 +val1);
					break;
				
				case '/':
					if (val1 == 0) {
						System.out.println("Cannot divide by zero.");
						break;
					}
					else {
						stack.push(val2 / val1);
						break;
					}
				
				case '*':
					stack.push(val2 * val1);
					break;
					
				case '%':
					stack.push(val2 % val1);
					break;
					
				case '^':
					int stemp = (int)Math.pow(val2, val1);
					stack.push(stemp);
					break;
				
				case '<':
					//empty compstr
					compstr.setLength(0);
					//add everything after < that isn't a digit to compstr
					while (!Character.isDigit(scan)) {
						compstr.append(scan);
						break;
					}
					//if it doesn't find <= then keep going
					if (compstr.indexOf("<=") == -1) {
						continue;
					}
					//if it does find <= then evaluate
					else if (compstr.indexOf("<=") != -1){
						if (val2 <= val1) {
							stack.push(1);
							break;
						}
						else {
							stack.push(0);
							break;
						}
					}
					else if (val2 < val1) {
						stack.push(1);
						break;
					}
					else {
						stack.push(0);
						break;
					}
				
				case '>':
					//empty compstr
					compstr.setLength(0);
					//add everything after < that isn't a digit to compstr
					while (!Character.isDigit(scan)) {
						compstr.append(scan);
					}
					//if it doesn't find >= then keep going
					if (compstr.indexOf(">=") == -1) {
						continue;
					}
					//if it does find >= then evaluate
					else if (compstr.indexOf(">=") != 1){
						if (val2 >= val1) {
							stack.push(1);
							break;
						}
						else {
							stack.push(0);
							break;
						}
					}
					else if (val2 > val1) {
						stack.push(1);
						break;
					}
					else {
						stack.push(0);
						break;
					}
					
				
				case '=':
					//empty compstr
					compstr.setLength(0);
					//add everything after < that isn't a digit to compstr
					while (!Character.isDigit(scan)) {
						compstr.append(scan);
						System.out.println("Compstr is: " + compstr);
						i++;
						break;
					}
					i--;
					//if it doesn't find == then keep going
					if (compstr.indexOf("==") == -1) {
						continue;
					}
					//if it does find == then evaluate
					else {
						if (val2 == val1) {
							stack.push(1);
							break;
						}
						else {
							stack.push(0);
							break;
						}
					}
				
				case '!':
					//empty compstr
					compstr.setLength(0);
					//add everything after < that isn't a digit to compstr
					while (!Character.isDigit(scan)) {
						compstr.append(scan);
						break;
					}
					//if it doesn't find != then keep going
					if (compstr.indexOf("!=") == -1) {
						continue;
					}
					//if it does find != then evaluate
					else {
						if (val2 != val1) {
							stack.push(1);
							break;
						}
						else {
							stack.push(0);
							break;
						}
					}
					
				case '&':
					//empty compstr
					compstr.setLength(0);
					//add everything after < that isn't a digit to compstr
					while (!Character.isDigit(scan)) {
						compstr.append(scan);
					}
					//if it doesn't find && then keep going
					if (compstr.indexOf("&&") == -1) {
						continue;
					}
					//if it does find && then evaluate
					else {
						//if (val2 == true && val1 == true) {
						//	stack.push(1);
						//}
						//else {
							stack.push(0);
							break;
						//}
					}
					
				case '|':
					//empty compstr
					compstr.setLength(0);
					//add everything after < that isn't a digit to compstr
					while (!Character.isDigit(scan)) {
						compstr.append(scan);
					}
					//if it doesn't find || then keep going
					if (compstr.indexOf("||") == -1) {
						continue;
					}
					//if it does find <= then evaluate
					else {
						//if (val2 == true || val1 == true) {
						//	stack.push(1);
						//}
						//else {
							stack.push(0);
							break;
						//}
					}

				}
			}
		
		}
		
		return stack.pop();
	}
	
	
	public static String infixToPostfix(String infixExp) {
		// Initialize an empty stack
		Stack<Character> stk = new Stack<>();
		// Initialize postfix string
		StringBuilder postfix = new StringBuilder();
		//Scanner scanner = new Scanner(infixExp);
		for (int i = 0; i < infixExp.length(); i++) {
			char token = infixExp.charAt(i);
			if (Character.isDigit(token)) { postfix.append(token).append(' '); }
			else if (Character.isWhitespace(token)) { continue; }
			// opening parenthesis
			else if (token == '(') { stk.push(token); }
			// closing parenthesis
			else if (token == ')') {
				while (!stk.peek().equals('(')) { postfix.append(stk.pop()).append(' '); }
				stk.pop();
			}
			// operator
			else {
				//if operator is comparison check next character to complete the operator
				if (token == '&' || token == '|' || token == '<' || token == '>' || token == '!') {
					if (infixExp.charAt(i + 1) == '&' || infixExp.charAt(i + 1) == '|' || infixExp.charAt(i + 1) == '=')
					token += infixExp.charAt(i + 1);
					i++;
				}
				while (!stk.isEmpty() && !stk.peek().equals('(') && precedence(token) <= precedence(stk.peek())) {
                    			postfix.append(stk.pop()).append(' ');
				}
				 // Push the current operator onto the stack.
                		stk.push(token);
			}
		}
		// Pop the remaining operators from the stack and append them to the postfix expression string.
        	while (!stk.isEmpty()) { postfix.append(stk.pop()).append(' '); }
        	//scanner.close();
        	return postfix.toString();
	}
	
	/** Returns the precedence of an operator.
		* @param operator: the operator to find its precedence
		* @return: the precedence of the operator
		*/
	public static int precedence(char token) {
		//Set each operators precedence
		//The higher the precedence the higher int returned
		if (token == ('^')) { return 7; }
		if (token == ('*') || token == ('/') || token == ('%')) { return 6; }
		if (token == ('+') || token == ('-')) { return 5; }
		if (token == ('<') || token == ('>')) { return 4; }
		if (token == ('=') || token == ('!')) { return 3; }
		if (token == ('&')) { return 2; }
		if (token == ('|')) { return 1; }
		// Throw exception for non supported operators
		throw new IllegalArgumentException(String.format("Operator %s is not a valid operator.", token));
	}


}
